## MSA에서 경계 나누기
* MSA 아키텍처를 적용하여 소프트웨어를 설계하다보면,
* 어떤 조건을 가지고, 어떤 특징을 가지고, 즉 어떤 기준으로 경계를 나누어야할까? 하는 고민을 하게 된다.
* 여기서 경계라는 것은 마이크로 서비스로 쪼개는 것을 의미한다.
* 이번 프로젝트에서 고민이 많이 되었던것은, 타임테이블과 예약이었다.

## 타임테이블 서비스
* 타임테이블 서비스는 타임테이블, 직역하면 시간표를 처리하는 서비스이다.
* 여기서 시간표는 가게의 예약표라고 생각하면 된다.
* 예약 가능한 시간대별 예약가능자 수 등을 저장하고있는 서비스이다.

## 예약 서비스
* 예약 서비스는 말그대로 예약을 처리하는 서비스이다.
* 그런데 무슨 고민이 들었다는 것인가?
* 그것은 예약을 하게되면 타임테이블이 영향을 받기 때문에 고민이 들었다.
* 예약을 하려면 타임테이블에 잔여 예약수가 남아있는지 체크도 해야하고,
* 예약이 성공되면 잔여 예약수가 마이너스되고,
* 예약이 취소되면 다시 잔여 예약수가 복구되어야한다.
* 타임테이블이 예약에 영향을 너무많이 받고, 거의 1대1로 대응되는 것 때문에 타임테이블을 예약에 넣어야하나 분리해야하나 고민이 들었다.

## 예약과 타임테이블은 분리한다.
* 결국은 예약과 타임테이블을 분리하기로 마음 먹었다.
* 마이크로서비스 아키텍처를 적용하는 이유자체도, 개별적으로 작게 띄어내서어
* 유지보수를 편리하게 하고, 쉽게 관리하는 등 모듈화시키는것이 주목적이기에
* 이에 부합하도록 목적이 서로다른 것들은 떼어내는 것이 옳다고 생각이 들었다.

## 서비스 끼리의 영향을 최소화하자.
* 떼어낸다고 능사는 아니다. 서비스끼리 너무 종속적이고, 너무 영향을 서로 주고받는다.
* 따라서 아래와 같은 매커니즘을 적용시켰다.
### 영향을 최소화하는 매커니즘
1. 예약을 진행한다. 
    * 이때 예약 서비스는 페인클라이언트를 이용해 타임테이블 서비스에 잔여 예약 가능자 수 검증과,
    * 잔여 예약자 수 마이너스 요청을 한다.
2. 타임테이블 서비스는 요청을 받아 업데이트 쿼리를 날린다. 
    * 업데이트 쿼리는 조건절을 이용해 잔여 예약자수가 남은경우에만 작동하도록한다.
    * 업데이트가 성공했다면 true값을, 아니라면 false를 넘겨준다.
3. 돌려받은 boolean 값을 이용해 적절한 처리를 한다.
    * 성공했다면 예약을 생성하고, 아니라면 예약이 실패했다는 것을 클라이언트에게 전달한다.
* 서킷브레이커를 이용해 타임테이블 서비스가 장애로 죽었다면 false를 리턴하여 처리한다.
* 예약 취소의 과정도 거의 동일하다.
* 이렇듯 일련의 과정을 함께 하지만, 주고받는 데이터도, 영향도 최소화하고
* 더 나아가 서킷브레이커로 상대 서비스의 장애에도 아무런 상관없도록 하여 서비스의 종속성을 완전히 분리시켰다.